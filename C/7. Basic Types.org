#+TITLE: Chapter 7. Loops
#+AUTHOR: vinci_g
#+DESCRIPTION: C Programming - A Modern Approach Chapter 7
#+OPTIONS: toc

* Table of Contents :toc:
- [[#integer-types][Integer Types]]
  - [[#signed--unsigned-integers][Signed & Unsigned Integers]]
  - [[#integer-constants][Integer Constants]]
  - [[#integer-overflow][Integer Overflow]]
  - [[#reading-and-writing-integers][Reading and Writing Integers]]
- [[#floating-types][Floating Types]]
  - [[#floating-constants][Floating Constants]]
  - [[#reading-and-writing-floating-point-numbers][Reading and Writing Floating-Point Numbers]]
- [[#character-types][Character Types]]
  - [[#operations-on-characters][Operations on Characters]]
  - [[#signed-and-unsigned-characters][Signed and Unsigned Characters]]

* Integer Types

** Signed & Unsigned Integers

The leftmost bit of a *signed* integer is 0 if the integer is positive or 0, and 1 if negative, while an *unsigned* integer have the leftmost bit to considered to be part of the number's magnitude.

Integer values in C are by default to be signed. Unsigned numbers are primarily used for systems programming.

The order of specifiers for data types doesn't matter; ~unsigned short int~ == ~short unsigned int~.

We can also omit the word ~int~. ~long int~ can just be ~long~, etc.

*** Integer Types in C99

C99 added ~long long int~ and ~unsigned long long int~ which is -2^63 to 2^63 - 1 and 0 to 2^64 - 1 respectively. This is to support 64-bit architecture and the need for very large integers.

** Integer Constants

Can be written as decimal, octal (starts with 0), or hexidecimal (starts with 0x) where octal and hex are the most convenient way to write low-level programs.

The compiler will infer the right type and specifier for a given constant but we can also force it to the constant for a specific type.

Add ~L~ for long, ~U~ for unsigned and ~UL~ or ~LU~ for unsigned long.

** Integer Overflow

Overflow happens when we perform arithmetic operations on integers and the result would be too large to represent.

Overflow on /signed/ integers are /undefined/ while defined on /unsigned/ integers.

** Reading and Writing Integers

| Conversion Specification | Read/Written As |
|--------------------------+-----------------|
| %u                       | unsigned int    |
| %o                       | octal           |
| %x                       | hexadecimal     |
| %h<type>                 | short type      |
| %l<type>                 | long type       |
| %ll<type>                | long long type  |


* Floating Types

C provides three floating point types:

| Type        | Description                       | Smallest Positive Value | Largest Value | Precision |
|-------------+-----------------------------------+-------------------------+---------------+-----------|
| float       | single-precision floating point   |           1.17549x10^-38 |  3.40282x10^38 | 6 digits  |
| double      | double-precision floating point   |          2.22507x10^-308 | 1.79769x10^308 | 15 digits |
| long double | extended-precision floating point |                         |               |           |

In *C99*, floating types are divided into two categories, the types discussed above are *real floating types* and *complex types*.

** Floating Constants

Floating constants must contain a decimal point and/or an exponent (preceded by the letter "e").

Floating constants are by default set to a ~double~ type which is not a problem as ~doubles~ are converted to ~float~ when necessary.

** Reading and Writing Floating-Point Numbers

| %f | fixed-point notation              |
| %e | exponential notation              |
| %g | either fixed point or exponential |

~%l<type>~ for double, ~%L<type>~ for long double.

* Character Types

~char~ is used for character types and can be assigned to any single character.

#+begin_src C
  char ch;

  ch = 'a';
  ch = 'A';
  ch = '0';
  ch = ' ';
#+end_src

Notice that character constants are enclosed in single quotes, which identifies it as a single character, for example ~'a'~. Using double quotes identifies it as a string literal which contains the character and a null character (making it a 2 char array).

** Operations on Characters

Characters are in a way, similar to integers wherein we can also do the arithmetic operations that we use for integers on characters. This is because each character has an ASCII value and it uses that to perform arithmetic operations on characters.

#+begin_src C
  char ch;

  ch = 65; /* evaluates to 'A' */
  ch += 1 /* evaluates to 'B' */
#+end_src

** Signed and Unsigned Characters



