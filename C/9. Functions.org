#+TITLE: Functions
#+AUTHOR: vinci
#+OPTIONS: toc

* Table of Contents :toc:
- [[#defining-and-calling-functions][Defining and Calling Functions]]
  - [[#function-definitions][Function Definitions]]
  - [[#function-calls][Function Calls]]
  - [[#function-declarations][Function Declarations]]
- [[#arguments][Arguments]]
  - [[#argument-conversions][Argument Conversions]]
  - [[#array-arguments][Array Arguments]]
  - [[#variable-length-array-parameters][Variable-Length Array Parameters]]
  - [[#using-static-in-array-parameter-declarations][Using ~static~ in Array Parameter Declarations]]
  - [[#compound-literals][Compound Literals]]
- [[#the-return-statement][The ~return~ Statement]]
- [[#program-termination][Program Termination]]

* Defining and Calling Functions
A function that returns a value: [[file:sample-program/average.c][average.c]].
A function that does not return a value: [[file:sample-program/countdown.c][countdown.c]].
A function that does not return a value and does not need arguments: [[file:sample-program/pun2.c][pun2.c]].

** Function Definitions
General form of a function definition:
#+begin_src
  return-type function-name ( parameters )
  {
    declarations
    statements
  }
#+end_src

*C99* requires a return type while *C89* assumes a return type of ~int~ if none is specified.

** Function Calls
Calling a non-void functions produces a value and can be assigned to a variable.

Example: [[file:sample-program/prime.c][prime.c]]

** Function Declarations
When we call a function before it is defined, the compiler makes implicit decisions on the return type, arguments, etc. When it is defined, the compiler then throws an error as it does not have the proper attributes when it was /implicitly declared/.

We can avoid this by defining all the functions before it is called. In a large program however this is hard so C introduces *function declaration* which gives the compiler a brief glimpse at a function whose full definition will appear later.

Syntax: ~return-type function-name ( parameters ) ;~

Sample program:
#+begin_src C
  #include <stdio.h>
  double average(double a, double b); /* DECLARATION */

  int main(void)
  {
    double x, y, z;

    printf("Enter three numbers: ");
    scanf("%lf%lf%lf", &x, &y, &z);
    printf("Average of %g and &g: %g\n", x, y, average(x, y));
    printf("Average of %g and &g: %g\n", y, z, average(y, z));
    printf("Average of %g and &g: %g\n", x, z, average(x, z));

    return 0;
  }

  double average(double a, double b) /* DEFINITION */
  {
    return (a + b) / 2;
  }
#+end_src

* Arguments
/Parameters/ are the dummy names appearing in function definitions. /Arguments/ are expressions that appear in function calls.

** Argument Conversions
C allows function calls wherein the types of the arguments doesn't match the parameter types.

Rules on how arguments are converted:
1. *The compiler has encountered a prototype prior to the call.* The value of each argument is implicitly converted to the type of the corresponding parameter as if by assignment.
2. *The compiler has not encountered a prototype prior to the call.* The compiler performs /default argument promotions/:
   - ~float~ arguments are converted to ~double~
   - Integral promotions are performed; ~char~ and ~short~ are converted to ~int~.

** Array Arguments
When a function parameter, the array length is usually left unspecified. The function however won't know how long the array is, so we supply another parameter that specifies the array length.

#+begin_src C
  int sum_array(int a[], int n) {
    int i, sum = 0;
    for (i = 0; i < n; i++) {
      sum += a[i];
    }
  }
#+end_src

When passing an array name into a function when it is already initialized, we omit ~[]~.

An important note to remember is that the function has no way to check if we passed the correct array length and we can leverage this by having the option to tell the function that the array is smaller than it really is. Just be careful not to pass a larger number than the array length.

When using arrays as arguments, the function is allowed to change the elements of the array parameter.

When using multidimensional arrays, only the length of the first dimension can be omitted when the parameter is declared.

#+begin_src C
  #define LEN 10

  int sum_two_dimensional_array(int a[][LEN], int n)
  {
    int i, j, sum = 0;

    for (i = 0; i < n; i++)
      for (j = 0; j < LEN; j++)
        sum += a[i][j];

    return sum;
  }
#+end_src

We can utilize the use of arrays of pointers to work around not being able to pass an arbitraty number of columns in multidimensional arrays.

** Variable-Length Array Parameters
For C99, the length of an array can be specified using a non-constant expression and VLAs can also be parameters.

#+begin_src c
  int sum_array(int n, int a[n]);
#+end_src

Notice that the first parameter ~n~ that specifies the length of the second parameter is now at the first because the compiler need to "see" ~n~ first before it can be used.

Order is important when VLA parameters are used.

We can also do:
#+begin_src c
  int sum_array(int n, int a[*]);

  int sum_array(int, int[*]);
#+end_src

The ~*~ provides a clue that the length of the array is related to the parameters that come earlier in the list. This is because parameter names are optional in function declarations.

Using VLA are most useful for multidimensional arrays as we can generalize the function to any number of columns.
#+begin_src c
  int sum_two_dimensional_array(int n, int m, int a[n][m])
  {
    int i, j, sum = 0;
    for (i = 0; i < n; i++)
      for (j = 0; j < m; j++)
        sum += a[i][j];

    return sum;
  }
#+end_src

The prototypes for this function include the ff:
#+begin_src c
  int sum_two_dimensional_array(int n, int m, int a[n][m]);
  int sum_two_dimensional_array(int n, int m, int a[*][*]);
  int sum_two_dimensional_array(int n, int m, int a[][m]);
  int sum_two_dimensional_array(int n, int m, int a[][*]);
#+end_src

** Using ~static~ in Array Parameter Declarations
~static~ is used to indicate that the value will never change.

Using ~static~ has no effect on the behavior of the program. It is just a hint that may allow the compiler to generate faster instructions for accessing the array.

#+begin_src c
  int sum_array(int a[static 3], int n);
#+end_src

Note that if an array parameter has > 1 dimensions then ~static~ can only be used in the 1st dimension.

** Compound Literals
Compound literals are unnamed arrays that is created on the fly by specifying the elements it contains.

#+begin_src c
  total = sum_array((int []){3, 0, 3, 4, 1}, 5);
#+end_src

We can also use arbitrary expressions for the elements for compound literals.
#+begin_src c
  total = sum_array((int []){2 * i, i + j, j * k}, 5);
#+end_src

A compound literal can be made read-only by adding the word ~const~.

* The ~return~ Statement
A non-void function must use the ~return~ statement to specify what value if will return.

Example use cases:
#+begin_src c
  return 0;
  return n >= 0 ? n : 0;
#+end_src

* Program Termination

